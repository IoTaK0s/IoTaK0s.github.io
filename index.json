[{"content":"TL;DR We are provided with the 1024 - 256 = 768 most significant bits of one of the primes used to compute $n$. Therefore, with the Coppersmith\u0026rsquo;s attack we can find the missing 256 bits and having $p$ it is trivial to break the RSA scheme.\nCode analysis First of all, it is important to understand the source code\nSource code:\nfrom Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD from secret import FLAG, KEY WELCOME = \u0026#34;\u0026#34;\u0026#34; ************** Welcome to the Gringatts Bank. ************** * * * Fortius Quo Fidelius * * * ************************************************************ \u0026#34;\u0026#34;\u0026#34; class RSA(): def __init__(self, key_length): self.e = 0x10001 phi = 0 prime_length = key_length // 2 while GCD(self.e, phi) != 1: self.p, self.q = getPrime(prime_length), getPrime(prime_length) phi = (self.p - 1) * (self.q - 1) self.n = self.p * self.q self.d = inverse(self.e, phi) def encrypt(self, message): message = bytes_to_long(message) return pow(message, self.e, self.n) def decrypt(self, encrypted_message): message = pow(encrypted_message, self.d, self.n) return long_to_bytes(message) class Bank: def __init__(self, rsa): self.options = \u0026#34;[1] Get public certificate.\\n[2] Calculate Hint.\\n[3] Unlock Vault.\\n\u0026#34; self.shift = 256 self.vaults = { f\u0026#34;vault_{i}\u0026#34;: [b\u0026#34;passphrase\u0026#34;, b\u0026#34;empty\u0026#34;] for i in range(100) } self.rsa = rsa def initializeVault(self, name, passphrase, data): self.vaults[name][0] = passphrase self.vaults[name][1] = data def calculateHint(self): return (self.rsa.p \u0026gt;\u0026gt; self.shift) \u0026lt;\u0026lt; self.shift def enterVault(self, vault, passphrase): vault = self.vaults[vault] if passphrase.encode() == vault[0]: return vault[1].decode() else: print(\u0026#34;\\nFailed to open the vault!\\n\u0026#34;) exit(1) if __name__ == \u0026#34;__main__\u0026#34;: rsa = RSA(2048) bank = Bank(rsa) vault = \u0026#34;vault_68\u0026#34; passphrase = KEY bank.initializeVault(vault, passphrase, FLAG) encrypted_passphrase = rsa.encrypt(bank.vaults[vault][0]) print(f\u0026#34;You managed to retrieve: {hex(encrypted_passphrase)[2:]}\u0026#34;) print(\u0026#34;\\nNow you are ready to enter the bank.\u0026#34;) print(WELCOME) while True: try: print(\u0026#34;Hello, what would you like to do?\\n\u0026#34;) print(bank.options) option = int(input(\u0026#34;\u0026gt; \u0026#34;)) if option == 1: print(f\u0026#34;\\n{bank.rsa.n}\\n{bank.rsa.e}\\n\u0026#34;) elif option == 2: print(f\u0026#34;\\n{bank.calculateHint()}\\n\u0026#34;) print(f\u0026#34;real p : {bank.rsa.p}\u0026#34;) elif option == 3: vault = input(\u0026#34;\\nWhich vault would you like to open: \u0026#34;) passphrase = input(\u0026#34;Enter the passphrase: \u0026#34;) print(f\u0026#34;\\n{bank.enterVault(vault, passphrase)}\\n\u0026#34;) else: \u0026#34;Abort mission!\u0026#34; exit(1) except KeyboardInterrupt: print(\u0026#34;Exiting\u0026#34;) exit(1) except Exception as e: print(f\u0026#34;An error occurred while processing data: {e}\u0026#34;) exit(1) We can see that SELF.SHIFT = 256 and RSA was initialized to have 2048 bit keys: rsa = RSA(2048) but the length of the primes is: key_length // 2\nTherefore, the primes are 1024 bits each. Also, if we look, there is a calculateHint function:\ndef calculateHint(self): return (self.rsa.p \u0026gt;\u0026gt; self.shift) \u0026lt;\u0026lt; self.shift. This function returns the most significant 768 bits of p. If we were able to get p we could easily break the RSA scheme.\nMathematical approach What we are going to do is to construct a polynomial: $$ f(x) = hint + x (mod\\hspace{0.2cm}p) $$ Let us define an $x_{0}$ such that: $$ x_{0} = p - hint $$ $$ f(x_{0}) = 0 $$ Our goal is to find the root $x_{0}$ so that we can recover $p$ in its entirety: $$ p = hint + x_{0} $$\nCoppersmith\u0026rsquo;s attack will help us to find a polynomial $pr$ with small coefficients that has the root $x_{0}$. He does all this through the LLL algorithm.\nI leave you some references about the Coppersmith\u0026rsquo;s attack that surely explain it much better than me:\nhttps://en.wikipedia.org/wiki/Coppersmith%27s_attack\nhttps://github.com/mimoo/RSA-and-LLL-attacks\nhttps://web.eecs.umich.edu/~cpeikert/lic13/lec04.pdf\nhttps://latticehacks.cr.yp.to/rsa.html\nhttps://www.di.ens.fr/~fouque/ens-rennes/coppersmith.pdf\nSolver The final solver is:\nn = 26211375773469184001318656141100500763313429420913368001374745099484088122316579885286487097911099553640485465879264776561059641793632440822902474437366178151344614399507216375584746495767257118136660752816908128374718028852908424721616601101869767341034562299604200292062539562260031509249703818987605113732956619399024336428546024215912865109661672719548634299576268423724640604152315140125167475937078671855333168331013934992701158252733536256484092658492790979124858563614501772552940266371220754690019124764001836316364805420248302098449705982955010188607337871438867444775767773706448611787974077408317620890183 e = 65537 nbits = n.nbits() known_bits = 256 hint = 177280817288627322094134834382081312724589047332204205138596571508970320442645568456603184647631801350766801962518302849576529462620705317421396164285474490176804856313329119058781152823294890779368691476727476669843207530678654823924746113011854165428215140997357968931347835865704536810100214150131131351040 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = (hint + x) x0 = f.small_roots(X=2^known_bits, beta=0.4)[0] p = hint + x0 print (hint + x0) If we run it we can see that we get the value of $p$.\n$ sage solver.sage 177280817288627322094134834382081312724589047332204205138596571508970320442645568456603184647631801350766801962518302849576529462620705317421396164285474490176804856313329119058781152823294890779368691476727476669843207530678654824005037352629664972062758886735010264329580233324956801766609726126137579798151 With this value of p we can easily obtain the decrypted message:\nfrom Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD import gmpy2 p = 177280817288627322094134834382081312724589047332204205138596571508970320442645568456603184647631801350766801962518302849576529462620705317421396164285474490176804856313329119058781152823294890779368691476727476669843207530678654824005037352629664972062758886735010264329580233324956801766609726126137579798151 n = 26211375773469184001318656141100500763313429420913368001374745099484088122316579885286487097911099553640485465879264776561059641793632440822902474437366178151344614399507216375584746495767257118136660752816908128374718028852908424721616601101869767341034562299604200292062539562260031509249703818987605113732956619399024336428546024215912865109661672719548634299576268423724640604152315140125167475937078671855333168331013934992701158252733536256484092658492790979124858563614501772552940266371220754690019124764001836316364805420248302098449705982955010188607337871438867444775767773706448611787974077408317620890183 q = n // p e = 65537 phi = (p - 1) * (q - 1) d = gmpy2.invert(e, phi) c = int(\u0026#34;147242eb8f9b480d9211897b5f1577e23fd595f23f290a0ec5b006c35cd843307749db797c523ca906904c078c04300a6f3af77f15ce19382d40f86b0709ebf23f2fb405d2bfa0dd649813004d83e6eb08a2ccfa8af7a94c69a8b6eb10a2478c181bfec8dc17a8749bd9e50394dd59b527375fdb4095efd95234876e7548c08e452438a081f9b0d7b5d11e0c24bf94946ab772ce7979691930d034829d0a9bb50835d848f4de4850c6c566ea7ba761ed747b7353934924d301e64e6f123f5be140af009acc13f019b5953bf152090752448995f84e6753737697ba8246a966e1357664e93597147bca6c5f4a9abe299382a67a1a5f6c081bd6071e05694c3a23\u0026#34;, 16) m = pow(c, d, n) print(long_to_bytes(m)) Obtained message:\n$ python3 solver.py b\u0026#34;The_horcrux_is_Helga_Hufflepuff\u0026#39;s_cup\u0026#34; Flag: We introduce The_horcrux_is_Helga_Hufflepuff's_cup as password in the server to open the vault and get the flag:\nHTB{LLL_4nd_c00p325m17h_15_57111_m491c_70_my_3y35} I hope you liked it and learned.\n","permalink":"https://IoTaK0s.github.io/posts/test/","summary":"TL;DR We are provided with the 1024 - 256 = 768 most significant bits of one of the primes used to compute $n$. Therefore, with the Coppersmith\u0026rsquo;s attack we can find the missing 256 bits and having $p$ it is trivial to break the RSA scheme.\nCode analysis First of all, it is important to understand the source code\nSource code:\nfrom Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, inverse, GCD from secret import FLAG, KEY WELCOME = \u0026#34;\u0026#34;\u0026#34; ************** Welcome to the Gringatts Bank.","title":"Bank-er-smith Writeup | Hack The Box Uni CTF"},{"content":"Welcome to our blog! üëã We are a group of cybersecurity and research enthusiasts friends who have decided to enter into the world of IoT security. In this blog, you will be able to find information related to the research we are doing, as well as the CVEs we are getting. We hope you like it and learn from it. You can contact us through twitter or mail.\nMembers of the team:\nDaniel Monz√≥n Diego Palacios Ismael Esquilichi David Rodr√≠guez Javier Valsera Carlos Barahona Pablo Redondo Pablo Pastor Jaime Cavero Francisco Mond√©jar David Billhardt Ra√∫l Mart√≠n Marcelino Siles ","permalink":"https://IoTaK0s.github.io/about/","summary":"about","title":"About us"}]